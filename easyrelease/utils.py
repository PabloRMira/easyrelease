# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_utils.ipynb (unless otherwise specified).

__all__ = ['check_git_dir', 'check_project_root', 'read_credentials', 'get_config', 'get_template', 'update_gitignore',
           'write_settings_ini', 'write_setup_py', 'write_conda_build_scripts', 'get_conda_env_packages']

# Cell
import os
import re
import functools
import tempfile
import pkgutil
import subprocess
from configparser import ConfigParser

# Cell
def check_git_dir():
    "Check whether there is a .git directory in your current folder"
    return bool(os.path.exists(".git"))

# Cell
def check_project_root(func):
    """Check that the user is on the project root directory by checking if there is a .git folder
    before running `func`
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if not check_git_dir():
            raise Exception("You need to be on your project root to execute this command")
        else:
            return func(*args, **kwargs)
    return wrapper

# Cell
@check_project_root
def read_credentials(path):
    "Read credentials from `path`"
    config = ConfigParser(delimiters=['='])
    with open(path, "r") as f:
        config.read_string("[DEFAULT]\n" + f.read())
    return config["DEFAULT"]

# Cell
def get_config():
    "Get config from settings.ini"
    config = ConfigParser(delimiters=['='])
    config.read('settings.ini')
    cfg = config['DEFAULT']
    return cfg

# Cell
def get_template(name):
    "Get template with filename `name`"
    template = pkgutil.get_data(__name__, f"templates/{name}").decode("utf-8")
    return template

# Cell
@check_project_root
def update_gitignore():
    "Update .gitignore with stuff we do not want to track"
    print("Updating .gitignore")
    add_ignore_files = [
        ".gh-credentials",
        "conda-recipe/*",
        "conda-bld/*"
    ]
    if os.path.exists(".gitignore"):
        with open(".gitignore", "r") as f:
            ignore_files = f.read().split("\n")
        for ifile in add_ignore_files:
            if ifile not in ignore_files:
                ignore_files.append(ifile)
        ignore_file = "\n".join(ignore_files)
    else:
        ignore_file = "\n"
    with open(".gitignore", "w") as f:
        f.write(ignore_file)

# Cell
@check_project_root
def write_settings_ini(project_type):
    "Write settings.ini from template"
    print("Generating settings.ini")
    if os.path.exists("settings.ini"):
        print("settings.ini already exists. Skipping this step")
    else:
        temp_name = "settings_template.ini" if project_type == "package" else "settings_slim_template.ini"
        template = get_template(temp_name)
        with open("settings.ini") as f:
            f.write(template)

# Cell
@check_project_root
def write_setup_py():
    "Write setup.py from template"
    print("Generating setup.py")
    if os.path.exists("setup.py"):
        print("setup.py already exists. Skipping this step")
    else:
        template = get_template("setup_template.py")
        with open("setup.py") as f:
            f.write(template)

# Cell
@check_project_root
def write_conda_build_scripts():
    "Write bld.bat and build.sh scripts for building conda packages"
    "Generating bld.bat and build.sh for conda recipe"
    if not os.path.exists("conda-recipe"):
        os.mkdir("conda-recipe")
    temp_map = {
        "bld.bat": "bld_template.bat",
        "build.sh": "build_template.sh"
    }
    for file_name, temp_name in temp_map.items():
        print(f"Generating file {file_name}")
        if os.path.exists(os.path.join("conda-recipe", file_name)):
            print(f"{file_name} already exists. Skipping this step")
        else:
            template = get_template(temp_name)
            with open(os.path.join("conda-recipe", file_name), "w") as f:
                f.write(template)

# Cell
def get_conda_env_packages():
    "Get conda environment packages"
    packages = subprocess.run(["conda", "list", "-e"], capture_output=True).stdout.decode("utf").splitlines()
    packages = [p for p in packages if not re.match(r"^#", p)]
    return packages